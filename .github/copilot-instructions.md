# Copilot Instructions for LawEthic
- Monorepo managed via npm workspaces; primary Next.js 14 App Router app (customer + admin) lives in [apps/web](apps/web). Shared Appwrite SDK helpers and types are in [packages/appwrite](packages/appwrite).
- Run commands from repo root: install with `npm install`; dev with `npm run dev` (all) or `npm run dev:web`; build/lint via `npm run build` / `npm run lint`; clean with `npm run clean`. Scripts like `update-permissions`, `seed`, `fix-attributes` use `tsx` and expect Appwrite credentials.
- Environment: configure Appwrite/Razorpay/Resend URLs and IDs in `.env.local` (see [packages/appwrite/config.ts](packages/appwrite/config.ts) for expected keys). Payments need `NEXT_PUBLIC_RAZORPAY_KEY_ID` + `RAZORPAY_KEY_SECRET`; emails need `RESEND_API_KEY` and `NEXT_PUBLIC_APP_URL` for links.
- Auth/Roles: roles are stored in Appwrite user prefs (`customer` | `operations` | `admin`) via [packages/appwrite/auth.ts](packages/appwrite/auth.ts). Admin gating is client-side with [apps/web/components/RoleGuard.tsx](apps/web/components/RoleGuard.tsx); middleware currently passes everything, so enforce checks in components/routes.
- Appwrite usage: client-side imports from `@lawethic/appwrite` use the browser SDK; server/API routes use `node-appwrite` or REST with `APPWRITE_API_KEY` (see [packages/appwrite/server.ts](packages/appwrite/server.ts)). Collections/buckets IDs are centralized in [packages/appwrite/config.ts](packages/appwrite/config.ts).
- Payment flow: `/api/payment/create-order` creates Razorpay orders using helpers in [apps/web/lib/razorpay.ts](apps/web/lib/razorpay.ts); `/api/payment/verify` validates signatures, updates the `orders` and `payments` collections, sets status `pending_docs`, then triggers invoice generation and fallback confirmation email.
- Invoices: [apps/web/lib/invoice/invoice-generator.ts](apps/web/lib/invoice/invoice-generator.ts) renders PDFs with `@react-pdf/renderer`, uploads to the `invoices` bucket via manual multipart fetch (keep this pattern for binary uploads), then updates order metadata and timeline + emails the customer. The download route currently lacks auth checks—add verification when extending.
- Certificates: Admin upload route [apps/web/app/api/admin/certificates/upload/route.ts](apps/web/app/api/admin/certificates/upload/route.ts) uses the same manual multipart approach, writes to `order_certificates`, adds timeline entries, and emails the customer. Reuse boundary-building code for any new file uploads to Appwrite storage.
- Documents: Admin document actions in [apps/web/app/api/admin/documents/action/route.ts](apps/web/app/api/admin/documents/action/route.ts) update statuses (`verified`/`rejected`), log to `order_timeline`, and push notifications to the customer.
- Messaging: [apps/web/app/api/messages/send/route.ts](apps/web/app/api/messages/send/route.ts) manually parses Appwrite session cookies from the request, validates the user via the REST `/account` endpoint, and writes to the `messages` collection; it then creates a notification for the other party. Follow the same cookie parsing + REST validation pattern for any user-authenticated API routes.
- Notifications: Notification helpers in [apps/web/lib/notifications](apps/web/lib/notifications) call `/api/notifications/create`, which writes directly to the `notifications` collection with `APPWRITE_API_KEY`. Use these helpers for status/message/certificate events instead of duplicating calls.
- Emails: [apps/web/lib/email/email-service.ts](apps/web/lib/email/email-service.ts) wraps Resend. In non-production it routes all mail to `RESEND_TEST_EMAIL` (default personal address). Templates exist for invoices, payment confirmations, status updates, document uploads, and certificate-ready alerts—reuse these before adding new ones.
- UI/Content patterns: Tailwind + shadcn/ui live under [apps/web/components/ui](apps/web/components/ui); general components and admin UI reside in [apps/web/components](apps/web/components). Navigation and service copy are in [apps/web/data](apps/web/data). Use `cn` from [apps/web/lib/utils.ts](apps/web/lib/utils.ts) for class merging.
- Data contracts: Appwrite model typings (orders, payments, documents, notifications, roles/status enums) are defined in [packages/appwrite/types.ts](packages/appwrite/types.ts); match these when extending APIs or collections.
- Known gaps: Invoice generate/download routes and admin APIs lack auth/role enforcement; Middleware currently allows all; add checks when touching these endpoints. Manual multipart uploads are required because the Node SDK stream API breaks under Next.js.

If anything here feels incomplete or unclear, point it out and I’ll refine this guide.
